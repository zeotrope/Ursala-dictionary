<html>
  <head>
    <link rel="stylesheet" type="text/css" href="dict.css" />
    <title>Operators</title>
  </head>
  <body>
    <a href="title.html"    >title</a>&nbsp;
    <a href="index.html"    >index</a>&nbsp;
    <a href="pointers.html" >pointers</a>&nbsp;
    operators&nbsp;
    <a href="types.html"    >types</a>&nbsp;
    <a href="phrases.html"  >phrases</a>&nbsp;
    <a href="primer.html"   >primer</a>&nbsp;
    <hr><br />

    <table cellpadding=5 width=100%>
      <tr>
	<td nowrap width=20%><tt>: </tt>&nbsp;&nbsp;assignment constructor</td>
	<td nowrap width=20%><tt>^:</tt>&nbsp;&nbsp;tree constructor</td>
	<td nowrap width=20%><a href="operators/o003.html"><tt>--</tt>&nbsp;&nbsp;append to list</a></td>
	<td nowrap width=20%><tt>-*</tt>&nbsp;&nbsp;left distribution</td>
	<td nowrap width=20%><tt>*-</tt>&nbsp;&nbsp;right distribution</td>
      </tr>
      <tr>
	<td nowrap><tt>~ </tt>&nbsp;&nbsp;deconstruction</td>
	<td nowrap><tt>:=</tt>&nbsp;&nbsp;address assignment</td>
	<td nowrap><tt>&&</tt>&nbsp;&nbsp;functional conjunction</td>
	<td nowrap><tt>||</tt>&nbsp;&nbsp;conjunction</td>
	<td nowrap><tt>!|</tt>&nbsp;&nbsp;disjunction</td>
      </tr>
      <tr>
	<td nowrap><tt>^&</tt>&nbsp;&nbsp;recursive conjunction</td>
	<td nowrap><tt>^!</tt>&nbsp;&nbsp;recursive logical or</td>
	<td nowrap><tt>-=</tt>&nbsp;&nbsp;membership</td>
	<td nowrap><tt>==</tt>&nbsp;&nbsp;comparison</td>
	<td nowrap><tt>~&lt</tt>&nbsp;&nbsp;non-member</td>
      </tr>
      <tr>
	<td nowrap><tt>~=</tt>&nbsp;&nbsp;deconstruction</td>
	<td nowrap><tt>-&gt</tt>&nbsp;&nbsp;address assignment</td>
	<td nowrap><tt>=&gt</tt>&nbsp;&nbsp;functional conjunction</td>
	<td nowrap><tt>:-</tt>&nbsp;&nbsp;conjunction</td>
	<td nowrap><tt>&lt:</tt>&nbsp;&nbsp;disjunction</td>
      </tr>
      <tr>
	<td nowrap><tt>*^</tt>&nbsp;&nbsp;tree folding</td>
	<td nowrap><tt>-$</tt>&nbsp;&nbsp;unzipped partial reification</td>
	<td nowrap><tt>-:</tt>&nbsp;&nbsp;total reification</td>
	<td nowrap><tt>!=</tt>&nbsp;&nbsp;bipartition by predicate</td>
	<td nowrap><tt>%=</tt>&nbsp;&nbsp;string substitution</td>
      </tr>
      <tr>
	<td nowrap><tt>=]</tt>&nbsp;&nbsp;startswith</td>
	<td nowrap><tt>[=</tt>&nbsp;&nbsp;prefix</td>
	<td nowrap><tt>$^</tt>&nbsp;&nbsp;maximum element</td>
	<td nowrap><tt>$-</tt>&nbsp;&nbsp;minimum element</td>
	<td nowrap><tt>-&lt</tt>&nbsp;&nbsp;sort list comparison</td>
      </tr>
      <tr>
	<td nowrap><tt>*|</tt>&nbsp;&nbsp;distributing bipartition</td>
	<td nowrap><tt>~|</tt>&nbsp;&nbsp;distributing filter</td>
	<td nowrap><tt>|=</tt>&nbsp;&nbsp;partition by equivalence compare</td>
      </tr>

      <tr><td nowrap>&nbsp;</td></tr>

      <tr>
	<td nowrap><tt>::</tt>&nbsp;&nbsp;declare record</td>
	<td nowrap><tt>= </tt>&nbsp;&nbsp;declare an identifier</td>
	<td nowrap><tt>| </tt>&nbsp;&nbsp;union of sets</td>
	<td nowrap><tt>/ </tt>&nbsp;&nbsp;fix left argument</td>
	<td nowrap><tt>\ </tt>&nbsp;&nbsp;fix right argument</td>	
      </tr>
      <tr>
	<td nowrap><tt>/*</tt>&nbsp;&nbsp;mapping binary to unary</td>
	<td nowrap><tt>\*</tt>&nbsp;&nbsp;reverse mapping binary to unary</td>
	<td nowrap><tt>. </tt>&nbsp;&nbsp;pointer, lambda</td>
	<td nowrap><tt>+ </tt>&nbsp;&nbsp;function composition</td>
	<td nowrap><tt>; </tt>&nbsp;&nbsp;sequential composition</td>	
      </tr>
      <tr>
	<td nowrap><tt>^ </tt>&nbsp;&nbsp;composition after coupling</td>
	<td nowrap><tt>^~</tt>&nbsp;&nbsp;couple, compose and fan</td>
	<td nowrap><tt>^|</tt>&nbsp;&nbsp;pairwise coupling</td>
	<td nowrap><tt>^*</tt>&nbsp;&nbsp;couple, compose and map</td>
	<td nowrap><tt>- </tt>&nbsp;&nbsp;table lookup</td>	
      </tr>
      <tr>
	<td nowrap><tt>.|</tt>&nbsp;&nbsp;defaultable library runtime</td>
	<td nowrap><tt>.!</tt>&nbsp;&nbsp;defaultable library compiletime</td>
	<td nowrap><tt>*~</tt>&nbsp;&nbsp;maximum element</td>
      </tr>

      <tr><td nowrap>&nbsp;</td></tr>

      <tr>
	<td nowrap><tt>! </tt>&nbsp;&nbsp;constant function</td>
	<td nowrap><tt>@ </tt>&nbsp;&nbsp;deconstruct compose</td>
	<td nowrap><tt>^=</tt>&nbsp;&nbsp;fixed point iteration</td>
	<td nowrap><tt>|\</tt>&nbsp;&nbsp;triangle</td>
	<td nowrap><tt>~~</tt>&nbsp;&nbsp;pairwise application</td>	
      </tr>
      <tr>
	<td nowrap><tt>? </tt>&nbsp;&nbsp;conditional</td>
	<td nowrap><tt>^?</tt>&nbsp;&nbsp;recursive conditional</td>
	<td nowrap><tt>?=</tt>&nbsp;&nbsp;comparing conditional</td>
	<td nowrap><tt>?$</tt>&nbsp;&nbsp;prefix conditional</td>
	<td nowrap><tt>?&lt</tt>&nbsp;&nbsp;inclusion conditional</td>
      </tr>
      <tr>
	<td nowrap><tt>$ </tt>&nbsp;&nbsp;raise record order</td>
	<td nowrap><tt>~*</tt>&nbsp;&nbsp;map to both</td>
	<td nowrap><tt>* </tt>&nbsp;&nbsp;map</td>
	<td nowrap><tt>*=</tt>&nbsp;&nbsp;flattening map</td>
	<td nowrap><tt>% </tt>&nbsp;&nbsp;literal type</td>
      </tr>
      <tr>
	<td nowrap><tt>%~</tt>&nbsp;&nbsp;bernoulli variable</td>
	<td nowrap><tt>-~</tt>&nbsp;&nbsp;forward bipartition</td>
	<td nowrap><tt>~-</tt>&nbsp;&nbsp;backward bipartition</td>
      </tr>
    </table>
  </body>
</html>
